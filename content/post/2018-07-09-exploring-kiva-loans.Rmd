---
title: Exploring Kiva loans
author: √Ångela D. Castillo-Gill
date: '2018-07-07'
slug: exploring-kiva-loans
categories:
  - R
  - EDA
tags: 
  - Kaggle
  - Kiva
summary: What do Kiva loans around the world look like?
output:
  blogdown::html_page:
    toc: true
    number_sections: true
    toc_depth: 1
---


```{r setup, include=FALSE}
x <-
  c("tidyverse",
    "bookdown",
    "knitr",
    "kableExtra",
    "formatR",
    "stringr",
    "rebus",
    "quantmode",
    "skimr",
    "lubridate",
    "broom",
    "tidyr",
    "GGally")

lapply(x, require, character.only = TRUE)


opts_chunk$set(echo = TRUE,
               warning = FALSE,
               error = FALSE,
               message = FALSE,
               collapse= TRUE,
               comment = NA,
               tidy = FALSE)

```

# Summary


# Purpose of this post

I'm learning machine learning with trees*. In order to practice the theory, nothing better than to put the learnings into a real case study and explain it. So, do you know [Kiva](www.kiva.org)? Kiva is a platform where everyone with access to internet and spare change can lend money to low-income entrepreneurs around the world. Pretty neat. 

{{% alert note %}} this is cool {{% /alert %}}

# The data

The dataset [with which I was first introduced](https://www.datacamp.com/courses/machine-learning-with-tree-based-models-in-r) to regression trees was a dataset with lots of information on people who were given loans and whether they had defaulted on the loan or not. I thought that was a neat application so I went to [Kaggle](https://www.kaggle.com/datasets) to find datasets related to loans. Here is where I found the [Kiva dataset](https://www.kaggle.com/kiva/data-science-for-good-kiva-crowdfunding) I will use in this post.  

Of course the dataset was super tidy and ready to go when I saw it since the point was to learn the algorithms, not to clean the database. In this post, I'll take you through everything I did, from the downloading of the data to the very last line of this post.

# What I did

The first step was to have a look at the dataset. This is pretty exciting. The zip file (232.7 MB) from Kaggle contained four files: `kiva_loans.csv`, `kiva_mpi_region_locations.csv`,`loan_theme_ids.csv`, and `loan_themes_by_region.csv`. 

```{r echo=T, results='hide',message=FALSE}
path <- "/Volumes/TOSHIBAEXT/RStudio/blog/content/post/kiva_data/"
#Read `kiva_loans.csv`
kiva_loans <- read_csv(paste(path,"kiva_loans.csv",sep = ""))
#Read `kiva_mpi_region_locations.csv`
kiva_locations <- read_csv(paste(path,"kiva_mpi_region_locations.csv",sep=""))
#Read `loan_theme_ids.csv`
kiva_themes <- read_csv(paste(path,"loan_theme_ids.csv",sep=""))
#Read`loan_themes_by_region.csv`
kiva_locations_themes <- read_csv(paste(path,"loan_themes_by_region.csv",sep=""))
```

Let's see what's inside. 

```{r}
#Get a glimpse of kiva_loans
glimpse(kiva_loans)
```

Wow! 671,205 observations and 20 variables.

Let's have a closer look at the data and see what each variable looks like.

- `funded_amount`: "The amount disbursed by Kiva to the field agent(USD)"
- `loan_amount`: "The amount disbursed by the field agent to the borrower(USD)"

Here, I am interested in the latter of those two variables as my response variable. 

- `activity`: "More granular category"
- `sector`: "High level category"
- `use`: "Exact usage of loan amount"

From these, I am going to pick `sector` because at first, I want to see if I can treat it like a factor in our regressions. The other ones are perhaps to specific to create levels.

- `country_code`: "ISO country code of country in which loan was disbursed"
- `country`: "Full country name of country in which loan was disbursed"
- `region`: "Full region name within the country"

I'm going to stick with `country_code` to make a factor with each country as a level.

- `currency`: "The currency in which the loan was disbursed"

Super important! In order to compare all loans, we need to translate them into the same currency.

- `partner_id`: "ID of partner organization"

This variable has a lot of missing values and the Kiva explanation on Kaggle doesn't go much further. For now, I will exclude `partner_id`. 

- `posted_time`: "The time at which the loan is posted on Kiva by the field agent"
- `disbursed_time`: "The time at which the loan is disbursed by the field agent to the borrower"
- `funded_time`: "The time at which the loan posted to Kiva gets funded by lenders completely"
- `term_in_months`: "The duration for which the loan was disbursed in months"
- `lender_count`: "The total number of lenders that contributed to this loan"
- `borrower_genders`: "Comma separated M,F letters, where each instance represents a single male/female in the group"
- `repayment_interval`: Not specified so we'll assume that it means the standard definition of when the loan is repaid back to the lender.

I'm including all in this last batch, they provide specific information for each loan which may prove useful later. Now let's create a new dataset with the selected variables with a few changes. 

# Data cleaning 
```{r}
#Select variables 
kiva_loans %>%
  dplyr::select (id,
          loan_amount,
          sector,
          country_code,
          currency,
          posted_time,
          disbursed_time,
          term_in_months,
          lender_count,
          borrower_genders,
          repayment_interval,
          funded_time) -> kiva_loans

#Convert country_code, sector, currency, borrower_genders, and repayment_interval to factors.
categorical <- c("sector",
                 "country_code",
                 "currency",
                 "borrower_genders",
                 "repayment_interval")

kiva_loans[categorical] <- lapply(kiva_loans[categorical],
                                  factor)
```

By having another glimpse at the structure of our data, we can soon see there are a few bits that don't make sense and need to be fixed. 

```{r summary}
summary(kiva_loans)
```
**a. Missing values**

Missing values, aka `NA's`, we could simply remove them since we have plenty of observations. But what if by removing them we introduce some bias. For example, `borrower_genders` has plenty of missing values, but what if this could say something about certain types of loans. For now we will leave them in.

**b.`borrower_genders`**

From the variable descriptions, we expected `borrower_genders`to have only two levels, `male`or `female`. Here we see there are many more levels, 11,298 to be precise. We know something is wrong here. So we'll fix that first. 

```{r }
#Turn kiva_loans back into an atomic vector of characters
kiva_loans$borrower_genders <- as.character(kiva_loans$borrower_genders)

#Split each row into multiple strings
genders <- str_split(kiva_loans$borrower_genders, ", ")

#Assign 1 for female and 0 for male
females_count <- lapply(genders, str_count, pattern="female")

#Count how many females are in each list element
females_sum <- lapply(females_count, sum)

#Create a function that takes the two lists just made
compare_genders <- function(females_count, females_sum){
  
  #Set "single_female" when female sum and length is 1
  ifelse (females_sum==1&&length(females_count)==1, "single_female",
          
  #Set "mult_females" when female sum and length females_count is the same and different to zero
  ifelse(females_sum==length(females_count)&&females_sum!=0,"mult_females",
         
  #Set "single_male" #Set "mult_males" when female sum is zero and the count of individuals is 1
  ifelse(females_sum==0&&length(females_count)==1,"single_male",
         
  #Set "mult_males" when female sum is zero and the count of individuals is greater than 1
  ifelse(females_sum==0&&length(females_count)>1,"mult_males",
         
  #Set "mixed_genders" when the sum of females is different to the count of individual       
  ifelse(females_sum!=length(females_count),"mixed_genders","strange")))))
  
}
#Apply function compare_genders
kiva_loans$borrower_genders <- mapply(compare_genders,females_count,females_sum)
```

Let's see if all is well...
```{r}
#Make kiva_loans$borrower_genders a factor again
kiva_loans$borrower_genders <- as.factor(kiva_loans$borrower_genders)

#Check levels
levels(kiva_loans$borrower_genders)
```
Nothing `strange`! Five levels as we wanted - fabulous! Onwards. 

**c.`loan_amounts`**

Now, since we're trying to predict `loan_amounts`, it's better if they're all in the same currency. Shall we translate them to USD? Here we go!

```{r error=FALSE}
for (curr in levels(kiva_loans$currency))
  
  #Check that all currencies do not return any errors when requesting a currency conversion
  tryCatch(quantmod::getQuote(paste0(curr, "=X")), error = print)
```

It seems like two currencies are returning an error. Let's filter them out. 

```{r}
#Turning kiva_loans back into a character vector
kiva_loans$currency <- as.character(kiva_loans$currency)

kiva_loans%>%
  #Filter out "SSP"
  dplyr::filter(currency!="SSP")%>% 
  
  #Filter out "ZWD"
  filter(currency!="ZWD")->kiva_loans 

#Turn kiva_loans$currency back into a factor
kiva_loans$currency <- as.factor(kiva_loans$currency) 

#Store all levels as vector `from`
from <- as.vector(levels(kiva_loans$currency)) 

#Create a vector `to` with requested currency "USD"
to <- rep(length(levels(kiva_loans$currency)),x="USD") 

#Create a dataframe `currencies` with conversion rates `Last`
currencies <- quantmod::getQuote(paste0(from, to, "=X"))
```

```{r}
#Set row names as columns in the currencies dataframe
currencies <- rownames_to_column(currencies)

#Split currencies$rownames by extracting the first 3 characters
currencies$currency <-  substring(currencies$rowname, 1,3)

kiva_loans%>%
  #Join currencies to kiva_loans by="currency"
  left_join(currencies, by="currency") -> kiva_loans

kiva_loans%>%
  #Convert the loan from its original currency to USD
  mutate(loan_usd=loan_amount*Last)-> kiva_loans
```


**d.`country_codes`**

Finally, with 86 countries, we have 86 levels. Perhaps it would be interesting to create another category called continent to produce less levels and have a better understanding of the overall function of regional distributions.

Our country codes are in the ISO3166 format, so we will use the associated continent code found [here](https://dev.maxmind.com/geoip/legacy/codes/country_continent/).

```{r}
#Read `country_continent.csv`
continents <- read_csv(paste(path,"country_continent.csv",sep = ""))
```

We will do what we previously did for currencies, which is to join both tables. 

```{r}
kiva_loans%>%
  #Join currencies to kiva_loans by="country_code"
  left_join(continents, by="country_code") -> kiva_loans

```

Let's see what happened...
```{r}
kiva_loans$continent <- as.factor(kiva_loans$continent)
levels(kiva_loans$continent)
```
5 continents! Africa, Asia, Europe, Oceania, and South America. Granted, we've lost spacial resolution. However, for our initial purpose, this is exactly what we wanted. 

**e. Dates**

Dates aren't numeric, but we can make them. Let's calculate two lengths of time that I think are interesting. 
First, how much time passes from the moment the loan is posted to the moment it's disbursed (`total_time`). Second, how long does a loan take to get funded (`giving_time`)? Let's find out!

```{r total_time_creation}
kiva_loans%>%
  mutate(total_time_num=as.numeric(difftime(posted_time,
                                            disbursed_time,
                                            units = "days")),
         giving_time_num=as.numeric(difftime(funded_time,
                                             posted_time,
                                             units = "days"))) ->kiva_loans

```


Final selection of variables...
```{r}
#Select variables 
kiva_loans %>%
  dplyr::select (id,
          loan_usd,
          sector,
          continent,
          term_in_months,
          lender_count,
          borrower_genders,
          repayment_interval,
          total_time_num,
          giving_time_num,
          country_code,
          posted_time,
          funded_time,
          disbursed_time)%>%
  arrange(posted_time)-> kiva_loans
kiva_loans$country_code <- as.factor(kiva_loans$country_code)
kiva_loans$id <- as.character(kiva_loans$id)
#Skim the dataset
skim(kiva_loans)
```


# Exploratory data analysis

Now let's describe the data. We could jump into the regression trees but exploring the data will help us interpret our predictions better. Do some extra work now and enjoy the benefits later. 

# Factors

Let's make two-way tables to understand our factors.

```{r}
prop.table(table(kiva_loans$borrower_genders))
prop.table(table(kiva_loans$continent))
prop.table(table(kiva_loans$repayment_interval))
prop.table(table(kiva_loans$sector))
```

We can see that most of the loans are requested by single females, that the least amount of loans are given in the EU, that weekly repayment is an unpopular form of paying the loan back and that entertainment, wholesale, manufacturing, and construction amount less than 2.2% of sectors. Let's remove these categories that are not representative of the data. 

```{r}
kiva_loans <-  kiva_loans%>%
  filter(continent!="EU",
         repayment_interval!="weekly",
         sector!="Construction"&
          sector!="Entertainment"&
           sector!= "Manufacturing"&
            sector!= "Wholesale")%>%
  droplevels()
```

Ideal. Now let's look at our factors in an easier way to parse. Let's compare genders by continents to see if we can spot anything worth noting.

```{r continent_and_borrower_genders_plots}
# Create side-by-side barchart of borrower_genders by continent
ggplot(kiva_loans, aes(x = continent, fill = borrower_genders)) + 
  geom_bar(position = "dodge") +theme_classic()
```

In all continents, single females request the most loans followed by single males. In Asia and South America, the third category is multiple females while in Africa it's mixed genders. 

```{r repayment_interval_and_continent}
#Create side-by-side barchart of repayment interval by continent
ggplot(kiva_loans,
       aes(x = continent, fill = repayment_interval)) + 
  geom_bar(position = "dodge")+
  theme_classic()
```

In Asia and Oceania, the most popular repayment interval is irregular while in Africa and South America it's monthly. 

```{r sectors_and_continents}

# Create side-by-side barchart of sector by continent
ggplot(kiva_loans, aes(x = continent, fill = sector)) + 
  geom_bar(position = "dodge")+ theme_classic()
```

In every continent, the three most popular sectors are agriculture, retail, and food. 

Finally, we still would like to understand which countries are requesting the most loans. Let'see.

```{r countries_plot, fig.height=5}
kiva_loans %>%
  group_by(country_code) %>%
  dplyr::count(country_code, sort = TRUE) %>%
  ungroup() %>%
  top_n(10) %>%
  ggplot(aes(reorder(x = country_code, n), y = n)) +
  geom_col(position = "dodge",
  color = "purple",
  fill = "purple") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Top 10 countries requesting Kiva Loans",
  x = "",
  y = "Country count")
```

We see that the Philippines is the country that requests the mosts loans with over double as the second country Kenya `KE`. Other top countries Cambodia `KH`, Pakistan `PK`, Peru `PE`, Colombia `CO`, Uganda `UG`, Tajikistan `TJ`, Ecuador `EC`, and Paraguay `PY`.


# Numeric variables 

Now let's look at the distributions of our numeric variables.

```{r loan_usd_distribution, fig.cap="Distribution of Kiva loans in USD"}

ggplot(kiva_loans, aes(x = loan_usd)) +
  geom_density() +
  theme_classic() +
  scale_x_continuous(limits = c(0, 15)) +
  geom_vline(
  xintercept = median(kiva_loans$loan_usd),
  color = "red",
  linetype = "dashed") +
  annotate(
  "text",
  label = paste("Median =",
  round(median(kiva_loans$loan_usd), digits = 2), "USD"),
  x = 5,
  y = 0.2,
  color = "red"
  ) +
  labs(title = "Distribution of Kiva loans in USD",
  x = "US dollars",
  y = "")
```

Figure \@ref(fig:loan_usd_distribution), shows that the distribution of Kiva loans in US dollars is right skewed and multimodal with its biggest peak around $1 and its second around $4. The median is about `r median(kiva_loans$loan_usd)`. 

```{r term_in_months_distribution}
ggplot(kiva_loans,
       aes(x=term_in_months))+
  geom_density()+
  theme_classic()+
  scale_x_continuous(limits=c(0,50))+
  geom_vline(xintercept = median(kiva_loans$term_in_months),
             color="red",
             linetype="dashed")+
  annotate("text",
           label=paste("Median =",
                              median(kiva_loans$term_in_months),"months"),
                x=18,
                y=0.2,
           color="red")
```
The loan term in months is a bimodal distribution with its first peak around 8 months and its second around 12, the median. 
```{r lender_count}
ggplot(kiva_loans,
       aes(x=lender_count))+
  geom_histogram()+
   theme_classic()+
  scale_x_continuous(limits=c(0,100))+
  geom_vline(xintercept = median(kiva_loans$lender_count),
             color="red",
             linetype="dashed")+
  annotate("text",
           label=paste("Median=",
                              median(kiva_loans$lender_count),"lenders"),
                x=21,
                y=150000,
           color="red")
```
The lender count has a text book right-skewed distribution with a median of 12 lenders. 
```{r giving_time}
ggplot(kiva_loans,
       aes(x=giving_time_num))+
  geom_density()+
   theme_classic()+
  scale_x_continuous(limits=c(0,50))+
  geom_vline(xintercept = median(kiva_loans$giving_time_num,na.rm=TRUE),
             color="red",
             linetype="dashed")+
  annotate("text",
           label=paste("Median=",
                       round(median(kiva_loans$giving_time_num,na.rm = TRUE)),digits=2,"days"),
           x=median(kiva_loans$giving_time_num,na.rm=TRUE)+5,
           y=0.1,
           color="red")
```
The median time between posting the loan and the loan being fully funded is about 9.2 days. It is a bimodal distribution with its first peak around 6 days and its second peak around 30 days. 
```{r total_time}
ggplot(kiva_loans,
       aes(x=total_time_num))+
  geom_density()+
   theme_classic()+
  scale_x_continuous(limits=c(0,50))+
  geom_vline(xintercept = median(kiva_loans$total_time_num,
                                 na.rm=TRUE),
             color="red",
             linetype="dashed")+
  annotate("text",
           label=paste("Median=",
                       round(median(kiva_loans$total_time_num,
                                    na.rm = TRUE)),digits=2,"days"),
           x=15+5,
           y=0.1,
           color="red")
```
The total time between posting the loan and it being disbursed has a funky looking multimodal distribution. It seems to be cut off at 30 days with peaks at 7, 14, 21 and 30 days. Median time is 17.2 days. 


# What I found out

# Conclusions


*LOL. Read that again outloud and laugh at the jargon put together in one short sentence. 